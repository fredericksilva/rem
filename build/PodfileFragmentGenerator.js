var __doc__, assert, co, findNativePackagesAsync, fs, instapromise, isString, jsonAsync, path, podfileFragmentAsync, rubyEscapeString, util;

__doc__ = "Generates a fragment of a Podfile on the fly that lists\nall the dependencies needed by the nativePackages under\nnode_modules\n";

assert = require('assert');

co = require('co');

fs = require('fs');

instapromise = require('instapromise');

isString = require('lodash-node').isString;

path = require('path');

util = require('util');

findNativePackagesAsync = co.wrap(function*(dir) {
  var awaitables, foundModules, i, len, mod, node_modules, pkg, ref;
  if (dir == null) {
    dir = '.';
  }
  "Finds all the React Native modules from a given directory";
  foundModules = [];
  pkg = (yield jsonAsync(path.join(dir, 'package.json')));
  if (pkg.nativePackage != null) {
    foundModules.push({
      path: path.relative('.', dir),
      name: pkg.name,
      version: pkg.version,
      nativePackage: pkg.nativePackage,
      pkg: pkg
    });
  }
  node_modules = path.join(dir, 'node_modules');
  if (fs.existsSync(node_modules)) {
    awaitables = [];
    ref = (yield fs.promise.readdir(node_modules));
    for (i = 0, len = ref.length; i < len; i++) {
      mod = ref[i];
      if (mod[0] !== '.') {
        awaitables.push(findNativePackagesAsync(path.join(node_modules, mod)));
      }
    }
    return foundModules.concat.apply(foundModules, (yield awaitables));
  } else {
    return foundModules;
  }
});

rubyEscapeString = function(s) {
  "Escapes a string for Ruby (for use in Podfiles)";
  assert(isString(s));
  return util.inspect(s);
};

jsonAsync = co.wrap(function*(filepath) {
  "Returns the JSON object from a given JSON file asynchronously";
  var e, json;
  json = (yield fs.promise.readFile(filepath, 'utf8'));
  try {
    return JSON.parse(json);
  } catch (_error) {
    e = _error;
    throw new Error((util.inspect(e)) + " in " + (path.resolve(filepath)));
  }
});

podfileFragmentAsync = co.wrap(function*(dir) {
  var defaultPodspec, i, len, name, nativePackages, np, pkg, podspecPath, podspecs, reactNativeApp, reactNativePath, ref;
  if (dir == null) {
    dir = '.';
  }
  "Returns the text of the Podfile we use for Rem";
  nativePackages = (yield findNativePackagesAsync(dir));
  podspecs = [];
  for (i = 0, len = nativePackages.length; i < len; i++) {
    np = nativePackages[i];
    if (np.nativePackage.podspec != null) {
      podspecs.push([np.name, path.join(np.path, np.nativePackage.podspec)]);
    } else {
      defaultPodspec = path.join(np.path, np.name + ".podspec");
      if (fs.existsSync(defaultPodspec)) {
        podspecs.push([np.name, defaultPodspec]);
      }
    }
  }
  pkg = (yield jsonAsync(path.join(dir, 'package.json')));
  reactNativeApp = pkg.reactNativeApp;
  reactNativePath = (ref = reactNativeApp != null ? reactNativeApp.reactNativePath : void 0) != null ? ref : 'node_modules/react-native';
  return "# Generated by rem for " + pkg.name + "\nREACT_NATIVE_PATH = " + (rubyEscapeString(reactNativePath)) + "\npod 'React', :path => REACT_NATIVE_PATH\npod 'React/RCTImage', :path => REACT_NATIVE_PATH\npod 'React/RCTText', :path => REACT_NATIVE_PATH\n" + (((function() {
    var j, len1, ref1, results;
    results = [];
    for (j = 0, len1 = podspecs.length; j < len1; j++) {
      ref1 = podspecs[j], name = ref1[0], podspecPath = ref1[1];
      results.push("pod " + (rubyEscapeString(name)) + ", :path => " + (rubyEscapeString(podspecPath)) + "\n");
    }
    return results;
  })()).join(''));
});

module.exports = {
  findNativePackagesAsync: findNativePackagesAsync,
  podfileFragmentAsync: podfileFragmentAsync,
  jsonAsync: jsonAsync
};

//# sourceMappingURL=sourcemaps/PodfileFragmentGenerator.js.map